esl4ElasticSearch
=================

Eazy Search Language for Elastic Search

为了能更简单的发挥Elastic Search的强大检索功能，我设计了一个属性检索语言（ESL）并用Go制作了解释器，但是公司整体上更希望有一套类SQL的语言来检索Elastic Search所以毙了它。但我认为属性检索这方面ESL更合适一些，所以开源以保留它的价值。

### 几个概念 ###

**识别符**：识别符是一个字符串，这个概念跟多数编程语言是相似的，但ESL不支持使用\开头的转义字符。

我们推荐识别符用双引号包含如 **"id"**，但是：

+ 当识别符本身就包含双引号时，可以用单引号如 **' "i"d" '**，此时识别符中的双引号只是普通字符。

+ 当识别符同时包含双引号和单引号时，可以用+号将它们相连，如 **'( " '+" ' )"**会生成 **( " ' )**。


**集合(SET)**: SET是由两个圆括号包含一个或以上的使用逗号分割的识别符组成，如 **("android", "iPhone", "WP","BB")**
+ SET不能为空,否则将引起编译错误。
+ 当SET里只有一个识别符时，实际上执行相等逻辑。
+ SET支持 **in** 和 **not in** 逻辑运算。如针对WP用户使用 **"mode" in ("Nokia")**，大约会有90%以上的概率返回真。但将来这个概率会下降，而 **"mode" in ("Microsoft")** 会返回真值的概率上升。

**区间(RANGE)**： RANGE是由两个方括号包含一个或两个使用冒号分割的识别符组成，前者表示开始，后者表示结束。如 **["18.5":"23.99"]** 表示体重指数区间，作者体重超过这个区间的最大值。
+ 可以省略其中之一，如你的理想体重指数是不设下限的比所有人“瘦”，集合会表示为 **[:"18.5"]**。
+ 同时省略开始和结束识别符会引发编译错误。
+ RANGE也支持 **in** 和 **not in** 逻辑运算，与SET类似。

**关系**： ESL只有三个关键字 **or，not，in**。
+ ESL有默认做and的逻辑（暂时没有and关键字），但有 **or** 。
+ **in** 表示某个属性属于某个集合或区间，它只适用于 **条件** 之内。
+ **not in** 实现与 **in** 相反的逻辑，它也只适用于 **条件** 之内。
+ **or** 适用于条件与条件之间或域与域之间。

**条件(COND)**： 条件是由一个属性识别符加 **in** / **not in** 再加  **SET/RANGE** 最后以分号结束。如：
>
"city" not in ("ShenZhen");

条件之间可以取并集。如：
>
"city" in ("ShenZhen") or "weight" in ["18.5":"23.99"];

**节(SECTION)**：若干条件的组合称为节，节会将它所有条件做交集。如下为两个条件组合而成的节：
>
"city" **not in** ("ShenZhen");
>
"regdate" **in** ["2014-11-11":"2014-12-12"];

**域(DOMAIN)**：用花括号将节包含起来称为一个域。域可以嵌套，也可以做 **or** 运算，同层次的域之间默认会做 **and** 运算。如：
>
{"city" **not in** ("ShenZhen");}
>
{"city" in ("XiAn");} or {"weight" in ["18.5":"23.99"];}

>
{{{{"city" **not in** ("ShenZhen");}}/*空嵌套*/}} /*交集*/ {"regdate" **in** ["2014-04-05":"2014-04-09"];}

**注释**：跟C语言一样，用 **/*和*/** 包含，上面的示例已经包含。但我们更推荐在ESL开头使用注释。如：
>/*在10月注册的深圳苹果用户加10月注册的除深圳外的广东省其它地区的安卓用户*/
>
>{"regdate" **in** ["2014-10-01":"2014-10-31"];}
>
>{
>
>>"city" in ("ShenZhen");
>
>>"platform" in ("IOS");
>
>}
>
>or
>
>{
>
>>"province" in ("GuangDong");
>
>>"city" not in ("ShenZhen");
>
>>"platform" in ("Android");
>
>}

**代码长度**：不得超过64KB。使用LL(N)解释器，不限制长度的代码会引发无限递归。一般认为64K足够，也可以适当加长。
